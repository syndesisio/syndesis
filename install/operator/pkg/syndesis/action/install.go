package action

import (
	"context"
	"errors"

	corev1 "k8s.io/api/core/v1"
	k8serrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"

	"k8s.io/client-go/kubernetes"

	"github.com/openshift/api/route/v1"

	"github.com/syndesisio/syndesis/install/operator/pkg/apis/syndesis/v1alpha1"
	"github.com/syndesisio/syndesis/install/operator/pkg/openshift/serviceaccount"
	"github.com/syndesisio/syndesis/install/operator/pkg/syndesis/addons"
	"github.com/syndesisio/syndesis/install/operator/pkg/syndesis/configuration"
	"github.com/syndesisio/syndesis/install/operator/pkg/syndesis/operation"
	syndesistemplate "github.com/syndesisio/syndesis/install/operator/pkg/syndesis/template"
	"sigs.k8s.io/controller-runtime/pkg/manager"
)

const (
	SyndesisRouteName  = "syndesis"
	SyndesisPullSecret = "syndesis-pull-secret"
)

// Install syndesis into the namespace, taking resources from the bundled template.
type installAction struct {
	baseAction
}

func newInstallAction(mgr manager.Manager, api kubernetes.Interface) SyndesisOperatorAction {
	return &installAction{
		newBaseAction(mgr, api, "install"),
	}
}

func (a *installAction) CanExecute(syndesis *v1alpha1.Syndesis) bool {
	return syndesisPhaseIs(syndesis, v1alpha1.SyndesisPhaseInstalling)
}

func (a *installAction) Execute(ctx context.Context, syndesis *v1alpha1.Syndesis) error {
	a.log.Info("Installing Syndesis resource", "name", syndesis.Name)

	// Check if an image secret exists, to be used to connect to registries that require authentication
	secret := &corev1.Secret{}
	err := a.client.Get(ctx, types.NamespacedName{Namespace: syndesis.Namespace, Name: SyndesisPullSecret}, secret)
	if err != nil {
		if k8serrors.IsNotFound(err) {
			secret = nil
		} else {
			return err
		}
	}

	token, err := installServiceAccount(ctx, a.client, syndesis, secret)
	if err != nil {
		return err
	}

	// Let's use a copy of the original parameter from now on, so that it can be changed inside this action
	originalSyndesis := syndesis
	syndesis = syndesis.DeepCopy()

	// Detect if the route should be auto-generated
	autoGenerateRoute := syndesis.Spec.RouteHostName == ""
	if autoGenerateRoute {
		syndesis.Spec.RouteHostName = "dummy"
	}

	params := syndesistemplate.InstallParams{
		OAuthClientSecret: token,
	}

	if _, ok := syndesis.Spec.Addons["komodo"]; ok {
		a.log.Info("Addon enabled", "addon", "komodo")
		params.DataVirtEnabled = true
	}

	list, err := syndesistemplate.GetInstallResourcesAsRuntimeObjects(a.scheme, syndesis, params)
	if err != nil {
		return err
	}

	syndesisRoute, err := installSyndesisRoute(ctx, a.client, syndesis, list, autoGenerateRoute)
	if err != nil {
		return err
	}

	if autoGenerateRoute {
		// Set the right hostname after generating the route
		syndesis.Spec.RouteHostName = syndesisRoute.Spec.Host

		// Hack to remove the auto-generated annotation
		// In OpenShift 3.9, the route gets low priority for being displayed as main route for the app if the openshift.io/host.generated=true annotation is present
		err = removeAutoGeneratedAnnotation(ctx, a.client, syndesisRoute)
		if err != nil {
			return err
		}

		// Recreate the list of resources to inject the route hostname
		list, err = syndesistemplate.GetInstallResourcesAsRuntimeObjects(a.scheme, syndesis, params)
	}

	// Link the image secret to service accounts
	if secret != nil {
		err = linkImageSecretToServiceAccounts(ctx, a.client, syndesis, list, secret)
		if err != nil {
			return err
		}
	}

	for _, res := range list {
		if _, isSyndesisRoute := isSyndesisRoute(res); isSyndesisRoute {
			// Syndesis route already installed
			continue
		}

		operation.SetNamespaceAndOwnerReference(res, syndesis)

		err = createOrReplace(ctx, a.client, res)
		if err != nil && !k8serrors.IsAlreadyExists(err) {
			return err
		}
	}

	// Install addons
	if addonsDir := *configuration.AddonsDirLocation; len(addonsDir) > 0 {
		addons, err := addons.GetAddonsResources(addonsDir)
		if err != nil {
			return err
		}
		for _, addon := range addons {
			operation.SetLabel(addon, "syndesis.io/addon-resource", "true")

			operation.SetNamespaceAndOwnerReference(addon, syndesis)

			err = createOrReplace(ctx, a.client, addon)
			if err != nil && !k8serrors.IsAlreadyExists(err) {
				return err
			}
		}
	}

	// Installation completed, set the next state
	target := originalSyndesis.DeepCopy()
	target.Status.Phase = v1alpha1.SyndesisPhaseStarting
	target.Status.Reason = v1alpha1.SyndesisStatusReasonMissing
	target.Status.Description = ""
	addRouteAnnotation(target, syndesisRoute)
	a.log.Info("Syndesis resource installed", "name", target.Name)

	return a.client.Update(ctx, target)
}

func installServiceAccount(ctx context.Context, cl client.Client, syndesis *v1alpha1.Syndesis, secret *corev1.Secret) (string, error) {
	sa := newSyndesisServiceAccount()
	if secret != nil {
		linkImagePullSecret(sa, secret)
	}
	operation.SetNamespaceAndOwnerReference(sa, syndesis)
	// We don't replace the service account if already present, to let Kubernetes generate its tokens
	err := cl.Create(ctx, sa)
	if err != nil && !k8serrors.IsAlreadyExists(err) {
		return "", err
	}

	return serviceaccount.GetServiceAccountToken(ctx, cl, sa.Name, syndesis.Namespace)
}

func newSyndesisServiceAccount() *corev1.ServiceAccount {
	sa := corev1.ServiceAccount{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "v1",
			Kind:       "ServiceAccount",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name: "syndesis-oauth-client",
			Labels: map[string]string{
				"app": "syndesis",
			},
			Annotations: map[string]string{
				"serviceaccounts.openshift.io/oauth-redirecturi.local":       "https://localhost:4200",
				"serviceaccounts.openshift.io/oauth-redirecturi.route":       "https://",
				"serviceaccounts.openshift.io/oauth-redirectreference.route": `{"kind": "OAuthRedirectReference", "apiVersion": "v1", "reference": {"kind": "Route","name": "syndesis"}}`,
			},
		},
	}

	return &sa
}

func addRouteAnnotation(syndesis *v1alpha1.Syndesis, route *v1.Route) {
	annotations := syndesis.ObjectMeta.Annotations
	if annotations == nil {
		annotations = make(map[string]string)
		syndesis.ObjectMeta.Annotations = annotations
	}
	annotations["syndesis.io/applicationUrl"] = extractApplicationUrl(route)
}
func extractApplicationUrl(route *v1.Route) string {
	scheme := "http"
	if route.Spec.TLS != nil {
		scheme = "https"
	}
	return scheme + "://" + route.Spec.Host
}

func installSyndesisRoute(ctx context.Context, cl client.Client, syndesis *v1alpha1.Syndesis, objects []runtime.Object, autoGenerate bool) (*v1.Route, error) {
	route, err := findSyndesisRoute(objects)
	if err != nil {
		return nil, err
	}

	operation.SetNamespaceAndOwnerReference(route, syndesis)

	if autoGenerate {
		route.Spec.Host = ""
	}

	// We don't replace the route if already present, to let OpenShift generate its host
	err = cl.Create(ctx, route)
	if err != nil && !k8serrors.IsAlreadyExists(err) {
		return nil, err
	}

	if route.Spec.Host != "" {
		return route, nil
	}

	// Let's try to get the route from OpenShift to check the host field
	var key client.ObjectKey
	if key, err = client.ObjectKeyFromObject(route); err != nil {
		return nil, err
	}
	err = cl.Get(ctx, key, route)
	if err != nil {
		return nil, err
	}

	if route.Spec.Host == "" {
		return nil, errors.New("hostname still not present on syndesis route")
	}

	return route, nil
}

func findSyndesisRoute(resources []runtime.Object) (*v1.Route, error) {
	for _, res := range resources {
		if route, ok := isSyndesisRoute(res); ok {
			return route, nil
		}
	}
	return nil, errors.New("syndesis route not found")
}

func isSyndesisRoute(resource runtime.Object) (*v1.Route, bool) {
	if route, ok := resource.(*v1.Route); ok {
		if route.Name == SyndesisRouteName {
			return route, true
		}
	}
	return nil, false
}

func isServiceAccount(resource runtime.Object) (*corev1.ServiceAccount, bool) {
	if sa, ok := resource.(*corev1.ServiceAccount); ok {
		return sa, true
	}
	return nil, false
}

func linkImageSecretToServiceAccounts(ctx context.Context, cl client.Client, syndesis *v1alpha1.Syndesis, resources []runtime.Object, secret *corev1.Secret) error {
	// Link the builder service account to the image pull/push secret if it exists
	builder := &corev1.ServiceAccount{}
	err := cl.Get(ctx, types.NamespacedName{Namespace: syndesis.Namespace, Name: "builder"}, builder)
	if err != nil {
		return err
	}
	linked := linkImagePullSecret(builder, secret)
	linked = linkSecret(builder, secret.Name) || linked
	if linked {
		err = cl.Update(ctx, builder)
		if err != nil {
			return err
		}
	}

	// Link the Syndesis service accounts to the image pull secret if it exists
	for _, res := range resources {
		if sa, ok := isServiceAccount(res); ok {
			linkImagePullSecret(sa, secret)
		}
	}

	return nil
}

func linkImagePullSecret(sa *corev1.ServiceAccount, secret *corev1.Secret) bool {
	exist := false
	for _, s := range sa.ImagePullSecrets {
		if s.Name == secret.Name {
			exist = true
			break
		}
	}

	if !exist {
		sa.ImagePullSecrets = append(sa.ImagePullSecrets, corev1.LocalObjectReference{
			Name: secret.Name,
		})
		return true
	}

	return false
}

func linkSecret(sa *corev1.ServiceAccount, secret string) bool {
	exist := false
	for _, s := range sa.Secrets {
		if s.Name == secret {
			exist = true
			break
		}
	}

	if !exist {
		sa.Secrets = append(sa.Secrets, corev1.ObjectReference{Namespace: sa.Namespace, Name: SyndesisPullSecret})
		return true
	}

	return false
}

func removeAutoGeneratedAnnotation(ctx context.Context, cl client.Client, route *v1.Route) error {
	return updateOnLatestRevision(ctx, cl, route, func(obj runtime.Object) {
		if r, ok := obj.(*v1.Route); ok {
			delete(r.Annotations, "openshift.io/host.generated")
		}
	})
}
