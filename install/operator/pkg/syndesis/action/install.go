package action

import (
	"context"
	"errors"

	corev1 "k8s.io/api/core/v1"
	k8serrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"

	"k8s.io/client-go/kubernetes"

	"github.com/openshift/api/route/v1"

	"github.com/syndesisio/syndesis/install/operator/pkg/apis/syndesis/v1alpha1"
	"github.com/syndesisio/syndesis/install/operator/pkg/openshift/serviceaccount"
	"github.com/syndesisio/syndesis/install/operator/pkg/syndesis/addons"
	"github.com/syndesisio/syndesis/install/operator/pkg/syndesis/configuration"
	"github.com/syndesisio/syndesis/install/operator/pkg/syndesis/operation"
	syndesistemplate "github.com/syndesisio/syndesis/install/operator/pkg/syndesis/template"
	"sigs.k8s.io/controller-runtime/pkg/manager"
)

const (
	SyndesisRouteName = "syndesis"
)

// Install syndesis into the namespace, taking resources from the bundled template.
type installAction struct {
	baseAction
}


func newInstallAction(mgr manager.Manager, api kubernetes.Interface) SyndesisOperatorAction {
	return &installAction{
		newBaseAction(mgr, api,"install"),
	}
}

func (a *installAction) CanExecute(syndesis *v1alpha1.Syndesis) bool {
	return syndesisPhaseIs(syndesis, v1alpha1.SyndesisPhaseInstalling)
}

func (a *installAction) Execute(ctx context.Context, syndesis *v1alpha1.Syndesis) error {

	a.log.Info("Installing Syndesis resource", "name", syndesis.Name)

	token, err := installServiceAccount(ctx, a.client, syndesis)
	if err != nil {
		return err
	}

	// Let's use a copy of the original parameter from now on, so that it can be changed inside this action
	originalSyndesis := syndesis
	syndesis = syndesis.DeepCopy()

	// Detect if the route should be auto-generated
	autoGenerateRoute := syndesis.Spec.RouteHostName == ""
	if autoGenerateRoute {
		syndesis.Spec.RouteHostName = "dummy"
	}

	list, err := syndesistemplate.GetInstallResourcesAsRuntimeObjects(a.scheme, syndesis, syndesistemplate.InstallParams{
		OAuthClientSecret: token,
	})
	if err != nil {
		return err
	}

	syndesisRoute, err := installSyndesisRoute(ctx, a.client, syndesis, list, autoGenerateRoute)
	if err != nil {
		return err
	}

	if autoGenerateRoute {
		// Set the right hostname after generating the route
		syndesis.Spec.RouteHostName = syndesisRoute.Spec.Host

		// Hack to remove the auto-generated annotation
		// In Openshift 3.9, the route gets low priority for being displayed as main route for the app if the openshift.io/host.generated=true annotation is present
		err = removeAutoGeneratedAnnotation(ctx, a.client, syndesisRoute)
		if err != nil {
			return err
		}

		// Recreate the list of resources to inject the route hostname
		list, err = syndesistemplate.GetInstallResourcesAsRuntimeObjects(a.scheme, syndesis, syndesistemplate.InstallParams{
			OAuthClientSecret: token,
		})
	}

	for _, res := range list {
		if _, isSyndesisRoute := isSyndesisRoute(res); isSyndesisRoute {
			// Syndesis route already installed
			continue
		}

		operation.SetNamespaceAndOwnerReference(res, syndesis)

		err = createOrReplace(ctx, a.client, res)
		if err != nil && !k8serrors.IsAlreadyExists(err) {
			return err
		}
	}

	// Install addons
	if addonsDir := *configuration.AddonsDirLocation; len(addonsDir) > 0 {
		addons, err := addons.GetAddonsResources(addonsDir)
		if err != nil {
			return err
		}
		for _, addon := range addons {
			operation.SetLabel(addon, "syndesis.io/addon-resource", "true")

			operation.SetNamespaceAndOwnerReference(addon, syndesis)

			err = createOrReplace(ctx, a.client, addon)
			if err != nil && !k8serrors.IsAlreadyExists(err) {
				return err
			}
		}
	}

	// Installation completed, set the next state
	target := originalSyndesis.DeepCopy()
	target.Status.Phase = v1alpha1.SyndesisPhaseStarting
	target.Status.Reason = v1alpha1.SyndesisStatusReasonMissing
	target.Status.Description = ""
	addRouteAnnotation(target, syndesisRoute)
	a.log.Info("Syndesis resource installed", "name", target.Name)

	return a.client.Status().Update(ctx, target)
}

func installServiceAccount(ctx context.Context, cl client.Client, syndesis *v1alpha1.Syndesis) (string, error) {
	sa := newSyndesisServiceAccount()
	operation.SetNamespaceAndOwnerReference(sa, syndesis)
	// We don't replace the service account if already present, to let Kubernetes generate its tokens
	err := cl.Create(ctx, sa)
	if err != nil && !k8serrors.IsAlreadyExists(err) {
		return "", err
	}

	return serviceaccount.GetServiceAccountToken(ctx, cl, sa.Name, syndesis.Namespace)
}

func newSyndesisServiceAccount() *corev1.ServiceAccount {
	sa := corev1.ServiceAccount{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "v1",
			Kind:       "ServiceAccount",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name: "syndesis-oauth-client",
			Labels: map[string]string{
				"app": "syndesis",
			},
			Annotations: map[string]string{
				"serviceaccounts.openshift.io/oauth-redirecturi.local":       "https://localhost:4200",
				"serviceaccounts.openshift.io/oauth-redirecturi.route":       "https://",
				"serviceaccounts.openshift.io/oauth-redirectreference.route": `{"kind": "OAuthRedirectReference", "apiVersion": "v1", "reference": {"kind": "Route","name": "syndesis"}}`,
			},
		},
	}

	return &sa
}

func addRouteAnnotation(syndesis *v1alpha1.Syndesis, route *v1.Route) {
	annotations := syndesis.ObjectMeta.Annotations
	if annotations == nil {
		annotations = make(map[string]string)
		syndesis.ObjectMeta.Annotations = annotations
	}
	annotations["syndesis.io/applicationUrl"] = extractApplicationUrl(route)
}
func extractApplicationUrl(route *v1.Route) string {
	scheme := "http"
	if route.Spec.TLS != nil {
		scheme = "https"
	}
	return scheme + "://" + route.Spec.Host
}

func installSyndesisRoute(ctx context.Context, cl client.Client, syndesis *v1alpha1.Syndesis, objects []runtime.Object, autoGenerate bool) (*v1.Route, error) {
	route, err := findSyndesisRoute(objects)
	if err != nil {
		return nil, err
	}

	operation.SetNamespaceAndOwnerReference(route, syndesis)

	if autoGenerate {
		route.Spec.Host = ""
	}

	// We don't replace the route if already present, to let Openshift generate its host
	err = cl.Create(ctx, route)
	if err != nil && !k8serrors.IsAlreadyExists(err) {
		return nil, err
	}

	if route.Spec.Host != "" {
		return route, nil
	}

	// Let's try to get the route from Openshift to check the host field
	var key client.ObjectKey
	if key, err = client.ObjectKeyFromObject(route); err != nil {
		return nil, err
	}
	err = cl.Get(ctx, key, route)
	if err != nil {
		return nil, err
	}

	if route.Spec.Host == "" {
		return nil, errors.New("hostname still not present on syndesis route")
	}

	return route, nil
}

func findSyndesisRoute(resources []runtime.Object) (*v1.Route, error) {
	for _, res := range resources {
		if route, ok := isSyndesisRoute(res); ok {
			return route, nil
		}
	}
	return nil, errors.New("syndesis route not found")
}

func isSyndesisRoute(resource runtime.Object) (*v1.Route, bool) {
	if route, ok := resource.(*v1.Route); ok {
		if route.Name == SyndesisRouteName {
			return route, true
		}
	}
	return nil, false
}

func removeAutoGeneratedAnnotation(ctx context.Context, cl client.Client, route *v1.Route) error {
	return updateOnLatestRevision(ctx, cl, route, func(obj runtime.Object) {
		if r, ok := obj.(*v1.Route); ok {
			delete(r.Annotations, "openshift.io/host.generated")
		}
	})
}
